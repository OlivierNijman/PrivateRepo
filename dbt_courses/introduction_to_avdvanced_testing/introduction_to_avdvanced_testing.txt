# Introduction to advanced testing

quick refresher:
tests are assertions you make about your models and other resources in you dbt project
dbt ensures data quality through a testing framework

why test?
feel comfortable and confident in the code you are writing
ensure your code continues to work as expected
help data consumers make data-informed decisions on accurate data
to increase likelihood of success/trust in the platform
save time as models documented with assertions helps future you (and others) contribute to the codebase

Testing techniques
interactive / ad hoc queries - e.g. when you test for uniqueness of a id of a table you made in a scratchpad
standalone saved query - statement in a sql file and it will run when you want to check results
expected results - adds context and information to your tests 
tests on a schedule - standalone test w/ expected results running automatically on a schedule

Take action! failures should be fixed immediately or silenced (lot of noise is meaningless)

Good test:
automated, fast, reliable, informative, focused, independent

What to test and why:
Tests on one database object (unique/not_null etc.)
    assert something about the data that you think is true 
    contents of the data
    constraints of the table
    grain of the table

Test how one database object refers to another database object  (relationships etc.)
    compare values in one model to a source of truth in another model
    ensure data has neither been erroneously added or removes

testing something unique about your data (order >= 0, etc.)
    tests usually involve some business logic / edge case / rare event

test the freshness of your raw source data (freshness tests, etc.)
    see if loading tool has added raw data to your source table 
    get notified if your underlying raw source data is not up to date 
    consider as the first step in your job to prevent models from running if data is delayed

temporary testing while refactoring (audit helper package)
    create confidence
    efficiently refactoring
    auditing your changes while in development

The path to a well-tested dbt project:
1. infancy - no tests
2. toddlerhood - primary key testing on your final models
3. childhood - 5 tests per model
4. adolescence - add advanced tests from packages
5. adulthood - high test coverage; advanced testing strategies

Measuring and enforcing test coverage
generic tests (unique/not_null etc.):
defined in yml files / acts on columns in raw data or model / 
dbt test or build to run test / seen in development adhoc and prod jobs

specific tests:
defined in test/<name>.sql files / acts on any models and fields referenced / 
dbt test or build to run test / seen in development adhoc and prod jobs

source freshness tests:
defined in staging/<name>.yml files / acts on declared column in underlying raw data (_loaded_at) / 
dbt source freshness to run / seen in prod jobs

project tests: 
defined in dbt_project.yml file / acts on whole project to test for defined tests / 
dbt run-operation or github action to run / seen in development adhoc and continuous integration checks

Establish norms in your company for what to test and when to test. 
Codify these norms using the package: `dbt_meta_testing` to ensure each object has the required tests. 

dbt-meta-testing package 
install external package
add suggested configuration to the dbt_project.yml file
run the check dbt run-operation required_tests
can add overrides in config block at the top {{ config(required_tests=None) }}

standardize and put it in CI check on github as well for pull requests. 

other packages to consider are dbt-coverage, pre-commit-dbt, dbt_dataquality, dbt-project-evaluator 

# Test Deployment

